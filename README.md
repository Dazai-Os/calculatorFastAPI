# FastAPI Calculator
__FastAPI__ __Calculator__ - это приложение калькулятора, написанное на языке программирование python с применением фреймворка FastAPI

### Что он умеет:
* Вычислять переданные значения слева направо (/calc)
* Просматривать последние от 0 до 30 записей (/history)

## Содержание:
1. Сборка проекта и локальный запуск
    * Клонируем репозиторий 
    * Настройка
    * Запуск
    * Открываем сайт
 2. Работа с калькулятором
    * Вычисление с одним аргументом
    * Вычисление с двумя аргументами
    * Запрос истории с default limit и заданным значением
3. Мысли по реализации
    * Ошибка с валидацией данных(или почему не выполнено одно требование)
    * Варианты решения
    * Почему asyncpg
    
____
    
## Сборка проекта и локальный запуск:
### Клонируем репозиторий
Выполните в консоли 
    
`git clone https://github.com/Dazai-Os/calculatorFastAPI`
    
    
`pip install -r requirements.txt`
    

### Настройка
Создайте файл .env и добавьте туда следующие параметры
```
DB_USER=имя пользователя базы данных

PG_PASSWORD=postgres пароль

DB_PASS=пароль от базы данных

DB_NAME=имя базы данных

DB_HOST=Хост базы данных
```
### Запуск приложения
В консоле запустите main.py

` python main.py `

### Открываем сайт
Переходим по ссылке http://127.0.0.1:8000/docs

Это авто документация предоставляемая самим FastAPI, что называется из коробки (реализует Swagger UI)

____

## Работа с калькулятором
### Вычисления с 1 аргументом
Открываем Post /calc кнопка Try  it out. В ставшем доступне окне заполняем json данные по примеру

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_18-48-26.jpg)

Ответ от сервера с успешным результатом:

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_19-06-40.jpg)

### Вычисления с 2 аргументами и более
Заполняем json файл по примеру(2 аргумента):

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-08-54.jpg)

Полученный ответ от сервера:

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-09-10.jpg)

От 2 и более аргументов

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-21-31.jpg)

Полученный ответ от сервера:

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-21-36.jpg)

Как можно было понять, чтобы добавить аргументы, мы их перечисляем через запятую в списке по примеру 2 аргумента

### Запрос истории с default и заданным  значением
Открываем Post /history нажимаем Try it out. В ставшем доступном окне заполняем json файл

С заданными параметрами:

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-27-02.jpg)

Ответ сервера:

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-27-07.jpg)

Значение по умолчанию 30, можно или вообше не изменять или передавать пустой json файл, как в примере:

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-31-24.jpg)

Ответ сервера(Сервер вернул только 6 значений, из-за того что в базе данных их всего 6):

![](https://github.com/Dazai-Os/calculatorFastAPI/blob/master/other(photo)/photo_2022-02-26_20-31-28.jpg)

____

## Мысли по реализации

### Ошибка с валидацией данных(или почему не выполнено одно требование)
   Как можно было заметить не было выполнено одно требование, endpoints /history не принимала и не сортировала данные по status. Это связано с тем, что при получении данных я валидирую их на соответствию выражению, если прилетает ошибочное выражение, данные не записываются, и отправляется ошибка пользователю о том, что неверно отправлены данные. 

   Поэтому некорректные данные даже не приходят в обработчик запроса пользователя, и я соответсвенно не могу добавить их в БД. Когда я понял что уже допустил эту ошибку вся логика calc была построена на том что я повторно не проверяю корректность пришедших мне данных и смело работаю с полученными данными. По факту все мои математические операции выполняются точно также как и в вашем требовании, за исключением того, что в БД не отправляются клиентские fail json файлы.
    
### Варианты решения
   Так я выяснил, какое есть несоответсвие требованиям тз, и здесь хотел бы предложить решение проблемы без изменения кода. Просто мне очень понравилось решение с валидатором, которое защищает нас от некоректных данных и не засоряет БД fail выражениями. 
   
   Одно из решений, которое сразу приходит на ум перенести логику валидаторов pydantic в функции обработки запроса пользователя и добавлением fail выражений при их несоответствии в БД.
   
  ### Почему asyncpg?
  В этом пункте хотел бы объяснить решение выбора бд и то как с ней работать. 
  Была идея попробовать что-то новое например связку легковесной встроенной бд sqlite в связке с orm sqlalchemy, но побоялся, что могу не успеть, не только из-за того что не знал sqlalchemy, но и то что могло бы понадобиться разворачивать docker для Бд(а с docker у меня отношения сразу не сложились, не работает он у меня и все... а очень жаль ведь открывает огромное количество возможностей, но как-нибудь руки точно дойдут до того чтобы настроить его) и решил использовать, то чем уже пользовался в своем прошлом проекте, а именно asyncpg. Т.к fastapi асинхронный он как раз сможет спокойно работать с нашей БД. В дополнение ко всему сказанному хотел бы написать и unit тесты, но из-за опаски со сжатыми сроками решил не писать тесты, из-за бд и то как pytest будет работать с asyncpg. Ну на этом собственно и все надеюсь, что все непонятные темы я покрыл, если что можете писать в telegram в резюме он был указан. Спасибо за уделенное моему проекту время
